-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj/hdlsrc/hdl_ofdm_tx/hdl_modulator/hdl_modulator_hdl_modulator.vhd
-- Created: 2018-02-27 13:25:15
-- 
-- Generated by MATLAB 9.3 and HDL Coder 3.11
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: hdl_modulator_hdl_modulator
-- Source Path: hdl_modulator
-- Hierarchy Level: 1
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY hdl_modulator_hdl_modulator IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        real_signal                       :   IN    std_logic_vector(19 DOWNTO 0);  -- sfix20_En13
        imag_signal                       :   IN    std_logic_vector(19 DOWNTO 0);  -- sfix20_En13
        baseband_mixed_signal             :   OUT   std_logic_vector(36 DOWNTO 0)  -- sfix37_En27
        );
END hdl_modulator_hdl_modulator;


ARCHITECTURE rtl OF hdl_modulator_hdl_modulator IS

  -- Component Declarations
  COMPONENT hdl_modulator_wave_generator
    PORT( u                               :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
          x                               :   OUT   std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
          y                               :   OUT   std_logic_vector(15 DOWNTO 0)  -- sfix16_En14
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : hdl_modulator_wave_generator
    USE ENTITY work.hdl_modulator_wave_generator(rtl);

  -- Signals
  SIGNAL real_signal_signed               : signed(19 DOWNTO 0);  -- sfix20_En13
  SIGNAL counter_wave_genation_out1       : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL count_to_fix_converter_out1      : unsigned(31 DOWNTO 0);  -- ufix32_En19
  SIGNAL samples_per_period_out1          : signed(31 DOWNTO 0);  -- sfix32_En5
  SIGNAL count_scaler_out1                : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Sine                             : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL Cosine                           : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL Cosine_signed                    : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Sine_signed                      : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL real_signal_modulator_out1       : signed(35 DOWNTO 0);  -- sfix36_En27
  SIGNAL imag_signal_signed               : signed(19 DOWNTO 0);  -- sfix20_En13
  SIGNAL imag_signal_modulator_out1       : signed(35 DOWNTO 0);  -- sfix36_En27
  SIGNAL tx_signal_adder_add_cast         : signed(36 DOWNTO 0);  -- sfix37_En27
  SIGNAL tx_signal_adder_add_cast_1       : signed(36 DOWNTO 0);  -- sfix37_En27
  SIGNAL tx_signal_adder_out1             : signed(36 DOWNTO 0);  -- sfix37_En27

BEGIN
  u_wave_generator : hdl_modulator_wave_generator
    PORT MAP( u => std_logic_vector(count_scaler_out1),  -- sfix16_En14
              x => Sine,  -- sfix16_En14
              y => Cosine  -- sfix16_En14
              );

  real_signal_signed <= signed(real_signal);

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 511
  counter_wave_genation_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      counter_wave_genation_out1 <= to_unsigned(16#0000#, 16);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        IF counter_wave_genation_out1 >= to_unsigned(16#01FF#, 16) THEN 
          counter_wave_genation_out1 <= to_unsigned(16#0000#, 16);
        ELSE 
          counter_wave_genation_out1 <= counter_wave_genation_out1 + to_unsigned(16#0001#, 16);
        END IF;
      END IF;
    END IF;
  END PROCESS counter_wave_genation_process;


  count_to_fix_converter_out1 <= counter_wave_genation_out1(12 DOWNTO 0) & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0';

  samples_per_period_out1 <= to_signed(16384, 32);

  count_scaler_output : PROCESS (count_to_fix_converter_out1, samples_per_period_out1)
    VARIABLE c : signed(31 DOWNTO 0);
    VARIABLE div_temp : signed(32 DOWNTO 0);
    VARIABLE cast : signed(32 DOWNTO 0);
  BEGIN
    IF samples_per_period_out1 = to_signed(0, 32) THEN 
      c := to_signed(2147483647, 32);
    ELSE 
      cast := signed(resize(count_to_fix_converter_out1, 33));
      div_temp := cast / samples_per_period_out1;
      IF (div_temp(32) = '0') AND (div_temp(31) /= '0') THEN 
        c := X"7FFFFFFF";
      ELSIF (div_temp(32) = '1') AND (div_temp(31) /= '1') THEN 
        c := X"80000000";
      ELSE 
        c := div_temp(31 DOWNTO 0);
      END IF;
    END IF;
    IF (c(31) = '0') AND (c(30 DOWNTO 15) /= X"0000") THEN 
      count_scaler_out1 <= X"7FFF";
    ELSIF (c(31) = '1') AND (c(30 DOWNTO 15) /= X"FFFF") THEN 
      count_scaler_out1 <= X"8000";
    ELSE 
      count_scaler_out1 <= c(15 DOWNTO 0);
    END IF;
  END PROCESS count_scaler_output;


  Cosine_signed <= signed(Cosine);

  Sine_signed <= signed(Sine);

  real_signal_modulator_out1 <= real_signal_signed * Sine_signed;

  imag_signal_signed <= signed(imag_signal);

  imag_signal_modulator_out1 <= Cosine_signed * imag_signal_signed;

  tx_signal_adder_add_cast <= resize(real_signal_modulator_out1, 37);
  tx_signal_adder_add_cast_1 <= resize(imag_signal_modulator_out1, 37);
  tx_signal_adder_out1 <= tx_signal_adder_add_cast + tx_signal_adder_add_cast_1;

  baseband_mixed_signal <= std_logic_vector(tx_signal_adder_out1);

END rtl;

